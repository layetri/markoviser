#lang racket

(require csd/lilypond)
(require csd/music_transforms)
(require midi-readwrite)
(require "./MidiParser.rkt")
(require "./Draw.rkt")
(require racket/struct)
(require racket/path)

(provide markovise)
(provide number-to-note)

; The Algorithm
(define possibilities (make-hash))
(define memory '())
(define memcount 0)

; Helper function: delete a sublist from a list by its first element
(define delete
    (lambda (item list)
        (cond
            ((equal? (car item) (caar list)) (cdr list))
            (else (cons (car list) (delete item (cdr list)))))))

; Helper function: translate a MIDI note number to a note name (NL/NL)
(define (number-to-note number)
    (define notes '(c cis d dis e f fis g gis a bes b))
    (list-ref notes (remainder number 12)))

; Generate a melody of a given length from a given set of possibilities
(define (markov-chain hash start len)
    (begin
        (define internal '())
        (if (eq? memcount 3)
            (set! internal (first (shuffle (delete memory (hash-ref hash start)))))
            (set! internal (first (shuffle (hash-ref hash start)))))
        (if (eq? internal memory)
            (+ memcount 1)
            (begin (set! memory internal) (set! memcount 1)))
        (if (eq? len 0) '()
            (begin
                (append (markov-chain hash internal (- len 1)) (list internal))))))

; Find all occurances of a key in a list and return it and its direct successor
(define (find-pairs-in-list lst key)
    (if (or (eq? (length lst) 1) (false? (member key (cdr lst))) (eq? (length (member key (cdr lst))) 1)) '()
        (append (list (cadr (member key lst))) (find-pairs-in-list (rest (member key lst)) key))))

; Parse a list of midi values into a hash table, with "probabilities"
(define (parse-to-hash lst)
    (define has-passed '())
    (begin
        (for ([i lst])
             (hash-set! possibilities i (find-pairs-in-list lst i)))))

; Print the generated melody to a file in the format of choice
(define (print-to-file melody path [format "lilypond"])
    (define filename (path->string (path-replace-extension path "")))
    (define rhythm (for/list ([j melody]) (second j)))
    (define mel (for/list ([i melody]) (first i)))

    (chain->bitmap possibilities filename)

    (cond [(eq? format "lilypond")
           (begin
               (lilypond-open (string-append filename ".ly"))
               (lilypond-title (path->string (car (reverse (explode-path path)))))
               (lilypond-composer "Generated by Markoviser.")

               (lilypond-write (make-phrase mel rhythm))
               (lilypond-close))]
          [else (displayln (string-append "The specified file type is not supported: " format))]))


; Function that bundles all aspects into one single process
; Arguments
; - file: path to midi source file
; - len: length of the generated melody
; - [optional] format: output format, defaults to LilyPond (options: "lilypond", "vsqx", "midi")
; - [optional] nogui: run the script without GUI, defaults to false

(define (markovise file [len 256] [output ""] [format "lilypond"] [nogui #f])
    ;parses the input file to a list of notes and lengths
    (begin
        (displayln "Importing file...")
        (cond [(not (path? file)) (set! file (string->path file))])
        (define midi-lst (midi-convert (midi-file-parse file)))

        (displayln "Parsing MIDI...")
        (parse-to-hash midi-lst)

        (displayln "Generating melody...")
        (define markovised (markov-chain possibilities (car (shuffle midi-lst)) len))

        (displayln (string-append "Exporting to " format " file..."))
        (print-to-file markovised output format)))